{"version":3,"file":"395.bundle.js","mappings":"gJAyBO,MAAMA,EACT,GACA,GACA,IAAU,EACV,GAAQ,KACR,GAAQ,KACR,GAAe,KACf,GAAY,KAEZ,GAAKC,GAQD,OANAC,MAAK,EAAYD,EAEjBC,MAAK,IAAiB,IAAIC,SAAQ,CAACC,EAASC,KACxCH,MAAK,EAAQ,CAACE,EAASC,EAAO,IAG3B,IAAIF,SAAQ,CAACC,EAASC,KACzBH,MAAK,GAAcI,KAAKF,GAASG,MAAMF,EAAO,GAEtD,CAEA,OAAM,CAAOJ,GAETC,MAAK,GAAU,EACf,UAEU,IAAAM,WAAUN,MAAK,EAAeD,EAAM,eA1CtDQ,eAAmCC,GAC/B,IAAK,IAAIC,EAAI,EAAGA,EA4CL,GA5CqBA,IAC5B,IACI,aAAaD,GACjB,CACA,MAAOE,GACH,KAAID,EAAIE,GAIJ,MAAMD,QAHA,IAAIT,SAASC,GAAYU,WAAWV,EAsCvC,MAjCX,CAER,CA6BkBW,EAAoBN,gBAChB,IAAAO,QAAOd,MAAK,EAAeA,MAAK,EAAU,IAGpDA,MAAK,IAAQ,IACjB,CACA,MAAOe,GAKH,MAHIA,aAAeC,OACfhB,MAAK,IAAQ,GAAGe,GAEdA,CACV,CACA,QAKI,GAHAf,MAAK,GAAU,EACfA,MAAK,EAAQA,MAAK,EAClBA,MAAK,EAAQA,MAAK,EAAe,KACV,OAAnBA,MAAK,EAAoB,CACzB,MAAMiB,EAAWjB,MAAK,EACtBA,MAAK,EAAY,WACXA,KAAKkB,MAAMD,EACrB,CACJ,CACJ,CACA,WAAAE,CAAYC,GACRpB,MAAK,EAAYoB,EACjBpB,MAAK,EA3Eb,SAAyBqB,GACrB,MAAMC,EAAID,aAAgBE,KAAM,IAAAC,eAAcH,GAAQA,EAAKI,WAC3D,OAAO,IAAAC,OAAK,IAAAC,SAAQL,GAAI,KAAI,IAAAM,UAASN,SACzC,CAwE6BO,CAAgBT,EACzC,CACA,WAAMF,CAAMnB,GACR,OAAOC,MAAK,EAAUA,MAAK,EAAKD,GAAQC,MAAK,EAAOD,EACxD,EChFG,MAAM+B,EACT,GACA,GACA,WAAAX,CAAYC,GACRpB,MAAK,EAAYoB,EACjBpB,MAAK,EAAU,IAAIF,EAAOsB,EAC9B,CACA,UAAMW,GACF,IAAIhC,EACJ,IACIA,QAAa,IAAAiC,UAAShC,MAAK,EAAW,QAC1C,CACA,MAAOiC,GACH,GAAe,WAAXA,EAAEC,KACF,OAAO,KAEX,MAAMD,CACV,CACA,OAAOlC,CACX,CACA,KAAAmB,CAAMiB,GACF,OAAOnC,MAAK,EAAQkB,MAAMiB,EAC9B,ECzBG,MAAMC,EACT,GACA,GACA,GACA,WAAAjB,CAAYC,GAAU,MAAEiB,EAAK,UAAEC,IAC3BtC,MAAK,EAAW,IAAI8B,EAASV,GAC7BpB,MAAK,EAASqC,EACdrC,MAAK,EAAasC,CACtB,CACA,UAAMP,GACF,MAAMhC,QAAaC,MAAK,EAAS+B,OACjC,OAAa,OAAThC,EACO,KAGAC,MAAK,EAAOD,EAE3B,CACA,KAAAmB,CAAMqB,GACF,OAAOvC,MAAK,EAASkB,MAAMlB,MAAK,EAAWuC,GAC/C,ECpBG,MAAM,UAAiBH,EAC1B,WAAAjB,CAAYC,GACRoB,MAAMpB,EAAU,CACZiB,MAAOI,KAAKJ,MACZC,UAAYvC,GAAS0C,KAAKH,UAAUvC,EAAM,KAAM,IAExD,E","sources":["webpack://server/./node_modules/steno/lib/index.js","webpack://server/./node_modules/lowdb/lib/adapters/node/TextFile.js","webpack://server/./node_modules/lowdb/lib/adapters/node/DataFile.js","webpack://server/./node_modules/lowdb/lib/adapters/node/JSONFile.js"],"sourcesContent":["import { rename, writeFile } from 'node:fs/promises';\nimport { basename, dirname, join } from 'node:path';\nimport { fileURLToPath } from 'node:url';\n// Returns a temporary file\n// Example: for /some/file will return /some/.file.tmp\nfunction getTempFilename(file) {\n    const f = file instanceof URL ? fileURLToPath(file) : file.toString();\n    return join(dirname(f), `.${basename(f)}.tmp`);\n}\n// Retries an asynchronous operation with a delay between retries and a maximum retry count\nasync function retryAsyncOperation(fn, maxRetries, delayMs) {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            return await fn();\n        }\n        catch (error) {\n            if (i < maxRetries - 1) {\n                await new Promise((resolve) => setTimeout(resolve, delayMs));\n            }\n            else {\n                throw error; // Rethrow the error if max retries reached\n            }\n        }\n    }\n}\nexport class Writer {\n    #filename;\n    #tempFilename;\n    #locked = false;\n    #prev = null;\n    #next = null;\n    #nextPromise = null;\n    #nextData = null;\n    // File is locked, add data for later\n    #add(data) {\n        // Only keep most recent data\n        this.#nextData = data;\n        // Create a singleton promise to resolve all next promises once next data is written\n        this.#nextPromise ||= new Promise((resolve, reject) => {\n            this.#next = [resolve, reject];\n        });\n        // Return a promise that will resolve at the same time as next promise\n        return new Promise((resolve, reject) => {\n            this.#nextPromise?.then(resolve).catch(reject);\n        });\n    }\n    // File isn't locked, write data\n    async #write(data) {\n        // Lock file\n        this.#locked = true;\n        try {\n            // Atomic write\n            await writeFile(this.#tempFilename, data, 'utf-8');\n            await retryAsyncOperation(async () => {\n                await rename(this.#tempFilename, this.#filename);\n            }, 10, 100);\n            // Call resolve\n            this.#prev?.[0]();\n        }\n        catch (err) {\n            // Call reject\n            if (err instanceof Error) {\n                this.#prev?.[1](err);\n            }\n            throw err;\n        }\n        finally {\n            // Unlock file\n            this.#locked = false;\n            this.#prev = this.#next;\n            this.#next = this.#nextPromise = null;\n            if (this.#nextData !== null) {\n                const nextData = this.#nextData;\n                this.#nextData = null;\n                await this.write(nextData);\n            }\n        }\n    }\n    constructor(filename) {\n        this.#filename = filename;\n        this.#tempFilename = getTempFilename(filename);\n    }\n    async write(data) {\n        return this.#locked ? this.#add(data) : this.#write(data);\n    }\n}\n","import { readFileSync, renameSync, writeFileSync } from 'node:fs';\nimport { readFile } from 'node:fs/promises';\nimport path from 'node:path';\nimport { Writer } from 'steno';\nexport class TextFile {\n    #filename;\n    #writer;\n    constructor(filename) {\n        this.#filename = filename;\n        this.#writer = new Writer(filename);\n    }\n    async read() {\n        let data;\n        try {\n            data = await readFile(this.#filename, 'utf-8');\n        }\n        catch (e) {\n            if (e.code === 'ENOENT') {\n                return null;\n            }\n            throw e;\n        }\n        return data;\n    }\n    write(str) {\n        return this.#writer.write(str);\n    }\n}\nexport class TextFileSync {\n    #tempFilename;\n    #filename;\n    constructor(filename) {\n        this.#filename = filename;\n        const f = filename.toString();\n        this.#tempFilename = path.join(path.dirname(f), `.${path.basename(f)}.tmp`);\n    }\n    read() {\n        let data;\n        try {\n            data = readFileSync(this.#filename, 'utf-8');\n        }\n        catch (e) {\n            if (e.code === 'ENOENT') {\n                return null;\n            }\n            throw e;\n        }\n        return data;\n    }\n    write(str) {\n        writeFileSync(this.#tempFilename, str);\n        renameSync(this.#tempFilename, this.#filename);\n    }\n}\n","import { TextFile, TextFileSync } from './TextFile.js';\nexport class DataFile {\n    #adapter;\n    #parse;\n    #stringify;\n    constructor(filename, { parse, stringify, }) {\n        this.#adapter = new TextFile(filename);\n        this.#parse = parse;\n        this.#stringify = stringify;\n    }\n    async read() {\n        const data = await this.#adapter.read();\n        if (data === null) {\n            return null;\n        }\n        else {\n            return this.#parse(data);\n        }\n    }\n    write(obj) {\n        return this.#adapter.write(this.#stringify(obj));\n    }\n}\nexport class DataFileSync {\n    #adapter;\n    #parse;\n    #stringify;\n    constructor(filename, { parse, stringify, }) {\n        this.#adapter = new TextFileSync(filename);\n        this.#parse = parse;\n        this.#stringify = stringify;\n    }\n    read() {\n        const data = this.#adapter.read();\n        if (data === null) {\n            return null;\n        }\n        else {\n            return this.#parse(data);\n        }\n    }\n    write(obj) {\n        this.#adapter.write(this.#stringify(obj));\n    }\n}\n","import { DataFile, DataFileSync } from './DataFile.js';\nexport class JSONFile extends DataFile {\n    constructor(filename) {\n        super(filename, {\n            parse: JSON.parse,\n            stringify: (data) => JSON.stringify(data, null, 2),\n        });\n    }\n}\nexport class JSONFileSync extends DataFileSync {\n    constructor(filename) {\n        super(filename, {\n            parse: JSON.parse,\n            stringify: (data) => JSON.stringify(data, null, 2),\n        });\n    }\n}\n"],"names":["Writer","data","this","Promise","resolve","reject","then","catch","writeFile","async","fn","i","error","maxRetries","setTimeout","retryAsyncOperation","rename","err","Error","nextData","write","constructor","filename","file","f","URL","fileURLToPath","toString","join","dirname","basename","getTempFilename","TextFile","read","readFile","e","code","str","DataFile","parse","stringify","obj","super","JSON"],"sourceRoot":""}